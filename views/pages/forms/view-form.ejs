<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title><%= formTitle %> - ASP Messina</title>

  <!-- Tailwind CSS via CDN -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Alpine.js for interactivity -->
  <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>

  <!-- Material Icons -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">

  <% if (recaptchaEnabled) { %>
  <!-- reCAPTCHA v3 -->
  <script src="https://www.google.com/recaptcha/api.js?render=<%= recaptchaSiteKey %>"></script>
  <% } %>

  <style>
    /* Material-UI Font */
    body {
      font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }

    /* Custom animations */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes slideIn {
      from { opacity: 0; transform: translateX(-20px); }
      to { opacity: 1; transform: translateX(0); }
    }

    @keyframes slideDown {
      from { opacity: 0; transform: scaleY(0.8); }
      to { opacity: 1; transform: scaleY(1); }
    }

    .fade-in {
      animation: fadeIn 0.3s ease-out;
    }

    .slide-in {
      animation: slideIn 0.4s ease-out;
    }

    .slide-down {
      animation: slideDown 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      transform-origin: top;
    }

    /* Custom scrollbar */
    ::-webkit-scrollbar {
      width: 10px;
    }

    ::-webkit-scrollbar-track {
      background: #f1f5f9;
    }

    ::-webkit-scrollbar-thumb {
      background: #cbd5e1;
      border-radius: 5px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #94a3b8;
    }

    /* Modern theme colors */
    .theme-modern {
      --primary: #3b82f6;
      --primary-dark: #2563eb;
      --secondary: #8b5cf6;
      --success: #10b981;
      --error: #ef4444;
    }

    .theme-healthcare {
      --primary: #0ea5e9;
      --primary-dark: #0284c7;
      --secondary: #06b6d4;
      --success: #14b8a6;
      --error: #f43f5e;
    }

    /* Checkbox and radio custom styles */
    input[type="checkbox"]:checked,
    input[type="radio"]:checked {
      background-color: var(--primary);
      border-color: var(--primary);
    }

    /* Focus states */
    input:focus, textarea:focus, select:focus {
      outline: none;
      border-color: var(--primary);
      ring: 2px;
      ring-color: var(--primary);
      ring-opacity: 0.5;
    }

    /* Error states */
    .field-error {
      border-color: var(--error) !important;
      background-color: #fef2f2;
    }

    .field-error:focus {
      border-color: var(--error) !important;
      ring-color: var(--error) !important;
    }

    /* Tooltip */
    .error-tooltip {
      position: relative;
      display: block;
      width: 100%;
    }

    .error-message {
      position: absolute;
      bottom: 100%;
      left: 0;
      background-color: var(--error);
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 0.875rem;
      white-space: nowrap;
      z-index: 10;
      margin-bottom: 5px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      animation: fadeIn 0.2s ease-out;
    }

    .error-message::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 20px;
      border: 6px solid transparent;
      border-top-color: var(--error);
    }

    /* Loading spinner */
    .spinner {
      border: 3px solid #f3f4f6;
      border-top: 3px solid var(--primary);
      border-radius: 50%;
      width: 24px;
      height: 24px;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Field label area with minimum height for consistent alignment */
    .field-label-area {
      min-height: 2.5rem;
    }

    /* Badge/Tag styles for selected items */
    .selected-badge {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 0.75rem;
      background-color: var(--primary);
      color: white;
      border-radius: 9999px;
      font-size: 0.875rem;
      margin: 0.25rem;
      transition: all 0.2s;
    }

    .selected-badge:hover {
      background-color: var(--primary-dark);
    }

    .badge-remove {
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 1.25rem;
      height: 1.25rem;
      border-radius: 50%;
      background-color: rgba(255, 255, 255, 0.2);
      transition: background-color 0.2s;
    }

    .badge-remove:hover {
      background-color: rgba(255, 255, 255, 0.4);
    }

    /* Dropdown results for tag input */
    .tag-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      max-height: 300px;
      overflow-y: auto;
      background: white;
      border: 1px solid #e5e7eb;
      border-radius: 0.5rem;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
      z-index: 20;
      margin-top: 0.25rem;
    }

    .tag-dropdown-item {
      padding: 1rem 1.25rem;
      cursor: pointer;
      transition: all 0.15s ease;
      border-bottom: 1px solid #f3f4f6;
      margin-bottom: 0.25rem;
      border-radius: 0.375rem;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .tag-dropdown-item:hover {
      background-color: #f3f4f6;
      transform: translateX(4px);
    }

    .tag-dropdown-item:last-child {
      border-bottom: none;
    }

    /* Material-UI Autocomplete/Select Styles */
    .mui-select-container {
      position: relative;
      width: 100%;
    }

    .mui-select-input {
      width: 100%;
      padding: 16px 48px 16px 16px;
      border: 1px solid rgba(0, 0, 0, 0.23);
      border-radius: 4px;
      font-size: 1rem;
      font-weight: 400;
      line-height: 1.5;
      color: rgba(0, 0, 0, 0.87);
      background: white;
      transition: border-color 0.2s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      cursor: pointer;
    }

    .mui-select-input:hover {
      border-color: rgba(0, 0, 0, 0.87);
    }

    .mui-select-input:focus,
    .mui-select-input.active {
      outline: none;
      border-color: #1976d2;
      border-width: 2px;
      padding: 15px 47px 15px 15px;
    }

    .mui-select-arrow {
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      pointer-events: none;
      color: rgba(0, 0, 0, 0.54);
      transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .mui-select-arrow.rotated {
      transform: translateY(-50%) rotate(180deg);
    }

    .mui-select-dropdown {
      position: absolute;
      top: calc(100% + 4px);
      left: 0;
      right: 0;
      max-height: 300px;
      overflow-y: auto;
      background: white;
      border-radius: 4px;
      box-shadow: 0px 5px 5px -3px rgba(0,0,0,0.2),
                  0px 8px 10px 1px rgba(0,0,0,0.14),
                  0px 3px 14px 2px rgba(0,0,0,0.12);
      z-index: 1300;
      margin: 0;
      padding: 8px 0;
    }

    .mui-select-option {
      padding: 12px 16px;
      cursor: pointer;
      transition: background-color 150ms cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 4px;
    }

    .mui-select-option:hover {
      background-color: rgba(0, 0, 0, 0.04);
    }

    .mui-select-option.selected {
      background-color: rgba(25, 118, 210, 0.08);
    }

    .mui-select-option-label {
      font-size: 1rem;
      font-weight: 400;
      color: rgba(0, 0, 0, 0.87);
    }

    .mui-select-option-subtitle {
      font-size: 0.875rem;
      color: rgba(0, 0, 0, 0.6);
    }

    .mui-search-input {
      width: calc(100% - 16px);
      margin: 0 8px 8px 8px;
      padding: 12px 16px;
      border: none;
      border-bottom: 1px solid rgba(0, 0, 0, 0.12);
      font-size: 1rem;
      outline: none;
      transition: border-color 0.2s;
    }

    .mui-search-input:focus {
      border-bottom-color: #1976d2;
      border-bottom-width: 2px;
    }

    .mui-no-results {
      padding: 16px;
      text-align: center;
      color: rgba(0, 0, 0, 0.6);
      font-size: 0.875rem;
    }
  </style>
</head>
<body class="bg-gradient-to-br from-slate-50 to-slate-100 min-h-screen py-8 px-4 theme-modern">

  <div id="app" x-data="formApp()" x-init="init()" class="max-w-4xl mx-auto">

    <!-- Header -->
    <div class="bg-white rounded-lg shadow-lg p-6 mb-6 fade-in">
      <h1 class="text-3xl font-bold text-gray-800 mb-2" x-text="formData.title"></h1>
      <p class="text-gray-600" x-text="formData.description" x-show="formData.description"></p>

      <!-- Progress bar for multi-page forms -->
      <div x-show="formData.pages && formData.pages.length > 1" class="mt-4">
        <div class="flex justify-between mb-2">
          <span class="text-sm font-medium text-gray-700">
            Pagina <span x-text="currentPage + 1"></span> di <span x-text="formData.pages ? formData.pages.length : 1"></span>
          </span>
          <span class="text-sm font-medium text-gray-700">
            <span x-text="Math.round(((currentPage + 1) / (formData.pages ? formData.pages.length : 1)) * 100)"></span>%
          </span>
        </div>
        <div class="w-full bg-gray-200 rounded-full h-2">
          <div class="bg-blue-500 h-2 rounded-full transition-all duration-300"
               :style="`width: ${((currentPage + 1) / (formData.pages ? formData.pages.length : 1)) * 100}%`">
          </div>
        </div>
      </div>
    </div>

    <!-- Loading state -->
    <div x-show="loading" class="bg-white rounded-lg shadow-lg p-12 text-center">
      <div class="spinner mx-auto mb-4"></div>
      <p class="text-gray-600">Caricamento modulo...</p>
    </div>

    <!-- Error state -->
    <div x-show="error" class="bg-red-50 border border-red-200 rounded-lg p-6 mb-6">
      <h3 class="text-red-800 font-semibold mb-2">Errore</h3>
      <p class="text-red-600" x-text="error"></p>
    </div>

    <!-- Form -->
    <form x-show="!loading && !error" @submit.prevent="submitForm()" class="space-y-6">

      <!-- Current Page -->
      <template x-if="formData.pages && formData.pages[currentPage]">
        <div class="bg-white rounded-lg shadow-lg p-6 slide-in" :key="currentPage">

          <!-- Page title -->
          <div class="mb-6">
            <h2 class="text-2xl font-semibold text-gray-800" x-text="formData.pages[currentPage].title"></h2>
            <p class="text-gray-600 mt-1" x-text="formData.pages[currentPage].description"
               x-show="formData.pages[currentPage].description"></p>
          </div>

          <!-- Fields -->
          <div class="grid grid-cols-1 md:grid-cols-2 gap-6 items-start">
            <template x-for="(field, index) in formData.pages[currentPage].fields" :key="field.id">
              <div class="fade-in" :class="getFieldColSpan(field)">

                <!-- Text input -->
                <template x-if="field.type === 'text'">
                  <div class="flex flex-col h-full">
                    <div class="field-label-area">
                      <label :for="field.id" class="block text-sm font-medium text-gray-700 mb-1">
                        <span x-text="field.label"></span>
                        <span x-show="field.required" class="text-red-500">*</span>
                      </label>
                      <p x-show="field.subtitle" class="text-xs text-gray-500 mb-1" x-text="field.subtitle"></p>
                    </div>
                    <div class="error-tooltip">
                      <input
                        :id="field.id"
                        :name="field.id"
                        type="text"
                        :placeholder="field.placeholder || ''"
                        x-model="formValues[field.id]"
                        @blur="validateField(field)"
                        @input="clearFieldError(field.id)"
                        :class="{'field-error': fieldErrors[field.id]}"
                        class="w-full px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 transition-all"
                      />
                      <div x-show="fieldErrors[field.id]" class="error-message" x-text="fieldErrors[field.id]"></div>
                    </div>
                    <p x-show="field.description" class="text-xs text-gray-500 mt-1" x-text="field.description"></p>
                  </div>
                </template>

                <!-- Textarea -->
                <template x-if="field.type === 'textarea'">
                  <div class="flex flex-col h-full">
                    <div class="field-label-area">
                      <label :for="field.id" class="block text-sm font-medium text-gray-700 mb-1">
                        <span x-text="field.label"></span>
                        <span x-show="field.required" class="text-red-500">*</span>
                      </label>
                      <p x-show="field.subtitle" class="text-xs text-gray-500 mb-1" x-text="field.subtitle"></p>
                    </div>
                    <div class="error-tooltip">
                      <textarea
                        :id="field.id"
                        :name="field.id"
                        :placeholder="field.placeholder || ''"
                        x-model="formValues[field.id]"
                        @blur="validateField(field)"
                        @input="clearFieldError(field.id)"
                        :class="{'field-error': fieldErrors[field.id]}"
                        rows="4"
                        class="w-full px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 transition-all"
                      ></textarea>
                      <div x-show="fieldErrors[field.id]" class="error-message" x-text="fieldErrors[field.id]"></div>
                    </div>
                    <p x-show="field.description" class="text-xs text-gray-500 mt-1" x-text="field.description"></p>
                  </div>
                </template>

                <!-- Radio buttons -->
                <template x-if="field.type === 'radio'">
                  <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">
                      <span x-text="field.label"></span>
                      <span x-show="field.required" class="text-red-500">*</span>
                    </label>
                    <p x-show="field.subtitle" class="text-xs text-gray-500 mb-2" x-text="field.subtitle"></p>
                    <div class="space-y-2">
                      <template x-for="option in field.options" :key="option.value">
                        <label class="flex items-start p-3 border border-gray-200 rounded-md hover:bg-gray-50 cursor-pointer transition-all">
                          <input
                            type="radio"
                            :name="field.id"
                            :value="option.value"
                            :required="field.required"
                            x-model="formValues[field.id]"
                            class="mt-1 mr-3"
                          />
                          <div class="flex-1">
                            <div class="font-medium text-gray-800" x-text="option.label"></div>
                            <div x-show="option.description" class="text-xs text-gray-500 mt-1" x-text="option.description"></div>
                          </div>
                        </label>
                      </template>
                    </div>
                    <p x-show="field.description" class="text-xs text-gray-500 mt-2" x-text="field.description"></p>
                  </div>
                </template>

                <!-- Checkboxes with Tags/Badge UI -->
                <template x-if="field.type === 'checkbox' || field.type === 'checkbox-multiple'">
                  <div x-data="{
                    searchQuery: '',
                    showDropdown: false,
                    getSelectedOptions() {
                      return field.options.filter(opt => formValues[field.id] && formValues[field.id].includes(opt.value));
                    },
                    getFilteredOptions() {
                      if (!this.searchQuery) return [];
                      const query = this.searchQuery.toLowerCase();
                      return field.options.filter(opt => {
                        const searchText = (opt.label + ' ' + (opt.subtitle || '') + ' ' + (opt.description || '')).toLowerCase();
                        return searchText.includes(query) && !(formValues[field.id] && formValues[field.id].includes(opt.value));
                      });
                    }
                  }">
                    <label class="block text-sm font-medium text-gray-700 mb-2">
                      <span x-text="field.label"></span>
                      <span x-show="field.required" class="text-red-500">*</span>
                    </label>
                    <p x-show="field.subtitle" class="text-xs text-gray-500 mb-2" x-text="field.subtitle"></p>

                    <!-- Selected badges -->
                    <div x-show="getSelectedOptions().length > 0" class="mb-3 flex flex-wrap">
                      <template x-for="option in getSelectedOptions()" :key="option.value">
                        <div class="selected-badge">
                          <span x-text="option.label"></span>
                          <span class="badge-remove" @click="updateCheckboxValue(field.id, option.value, false); $el.closest('[x-data]').searchQuery = ''">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                              <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
                            </svg>
                          </span>
                        </div>
                      </template>
                    </div>

                    <!-- Search input with dropdown -->
                    <div class="relative">
                      <input
                        type="text"
                        x-model="searchQuery"
                        @focus="showDropdown = true"
                        @blur="setTimeout(() => showDropdown = false, 200)"
                        @input="showDropdown = true"
                        :placeholder="field.placeholder || 'Cerca e seleziona...'"
                        class="w-full px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 transition-all"
                      />

                      <!-- Dropdown results -->
                      <div x-show="showDropdown && getFilteredOptions().length > 0" class="tag-dropdown">
                        <template x-for="option in getFilteredOptions()" :key="option.value">
                          <div
                            class="tag-dropdown-item"
                            @click="updateCheckboxValue(field.id, option.value, true); searchQuery = ''; showDropdown = false"
                          >
                            <div class="font-medium text-gray-800" x-text="option.label"></div>
                            <div x-show="option.subtitle" class="text-sm text-gray-600 mt-0.5" x-text="option.subtitle"></div>
                          </div>
                        </template>
                      </div>
                    </div>

                    <p x-show="field.description" class="text-xs text-gray-500 mt-2" x-text="field.description"></p>
                  </div>
                </template>

                <!-- Material-UI Select dropdown -->
                <template x-if="field.type === 'select'">
                  <div class="flex flex-col h-full" x-data="{
                    open: false,
                    searchQuery: '',
                    getSelectedLabel() {
                      const selected = field.options.find(opt => opt.value === formValues[field.id]);
                      return selected ? selected.label : '';
                    },
                    getSelectedSubtitle() {
                      const selected = field.options.find(opt => opt.value === formValues[field.id]);
                      return selected && selected.subtitle ? selected.subtitle : '';
                    },
                    getFilteredOptions() {
                      if (!field.searchable || !this.searchQuery) return field.options;
                      const query = this.searchQuery.toLowerCase();
                      return field.options.filter(opt => {
                        const searchText = (opt.label + ' ' + (opt.subtitle || '')).toLowerCase();
                        return searchText.includes(query);
                      });
                    },
                    selectOption(value) {
                      formValues[field.id] = value;
                      this.open = false;
                      this.searchQuery = '';
                      clearFieldError(field.id);
                    }
                  }" @click.outside="open = false">
                    <div class="field-label-area">
                      <label :for="field.id" class="block text-sm font-medium text-gray-700 mb-1">
                        <span x-text="field.label"></span>
                        <span x-show="field.required" class="text-red-500">*</span>
                      </label>
                      <p x-show="field.subtitle" class="text-xs text-gray-500 mb-1" x-text="field.subtitle"></p>
                    </div>

                    <div class="mui-select-container">
                      <div
                        @click="open = !open; if(open && field.searchable) $nextTick(() => $refs.searchInput.focus())"
                        class="mui-select-input"
                        :class="{'active': open, 'field-error': fieldErrors[field.id]}"
                      >
                        <template x-if="formValues[field.id]">
                          <div>
                            <div x-text="getSelectedLabel()" class="mui-select-option-label"></div>
                            <div x-show="getSelectedSubtitle()" x-text="getSelectedSubtitle()" class="mui-select-option-subtitle"></div>
                          </div>
                        </template>
                        <template x-if="!formValues[field.id]">
                          <span class="text-gray-400" x-text="field.placeholder || 'Seleziona un\'opzione...'"></span>
                        </template>
                      </div>

                      <span class="mui-select-arrow" :class="{'rotated': open}">
                        <span class="material-icons">expand_more</span>
                      </span>

                      <div x-show="open" x-transition class="mui-select-dropdown slide-down">
                        <template x-if="field.searchable">
                          <input
                            x-ref="searchInput"
                            type="text"
                            x-model="searchQuery"
                            @click.stop
                            placeholder="Cerca..."
                            class="mui-search-input"
                          />
                        </template>

                        <template x-for="option in getFilteredOptions()" :key="option.value">
                          <div
                            @click="selectOption(option.value)"
                            class="mui-select-option"
                            :class="{'selected': formValues[field.id] === option.value}"
                          >
                            <div class="mui-select-option-label" x-text="option.label"></div>
                            <div x-show="option.subtitle" class="mui-select-option-subtitle" x-text="option.subtitle"></div>
                          </div>
                        </template>

                        <div x-show="getFilteredOptions().length === 0" class="mui-no-results">
                          Nessun risultato trovato
                        </div>
                      </div>

                      <div x-show="fieldErrors[field.id]" class="error-message" x-text="fieldErrors[field.id]"></div>
                    </div>

                    <p x-show="field.description" class="text-xs text-gray-500 mt-1" x-text="field.description"></p>
                  </div>
                </template>

              </div>
            </template>
          </div>

        </div>
      </template>

      <!-- Navigation buttons -->
      <div class="bg-white rounded-lg shadow-lg p-6 flex justify-between items-center">

        <!-- Previous button -->
        <button
          type="button"
          @click="previousPage()"
          x-show="currentPage > 0"
          class="px-6 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300 transition-all font-medium"
        >
          Indietro
        </button>

        <div x-show="currentPage === 0"></div>

        <!-- Next button -->
        <button
          type="button"
          @click="nextPage()"
          x-show="currentPage < (formData.pages ? formData.pages.length - 1 : 0)"
          class="px-6 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-all font-medium"
        >
          Avanti
        </button>

        <!-- Submit button -->
        <button
          type="submit"
          x-show="currentPage === (formData.pages ? formData.pages.length - 1 : 0)"
          :disabled="submitting"
          class="px-6 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 transition-all font-medium disabled:opacity-50 disabled:cursor-not-allowed flex items-center"
        >
          <span x-show="!submitting" x-text="formData.submitButton ? formData.submitButton.text : 'Invia'"></span>
          <span x-show="submitting" class="flex items-center">
            <span class="spinner mr-2"></span>
            <span x-text="formData.submitButton ? formData.submitButton.loadingText : 'Invio...'"></span>
          </span>
        </button>

      </div>

    </form>

    <!-- Success message -->
    <div x-show="submitted" class="bg-green-50 border border-green-200 rounded-lg p-6 text-center fade-in">
      <svg class="w-16 h-16 text-green-500 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
      </svg>
      <h3 class="text-green-800 font-semibold text-xl mb-2">Inviato con successo!</h3>
      <p class="text-green-600" x-text="formData.messages?.success || 'Grazie! Il modulo è stato inviato con successo.'"></p>
    </div>

  </div>

  <script>
    function formApp() {
      return {
        formId: '<%= formId %>',
        formData: {},
        formValues: {},
        fieldErrors: {},
        currentPage: 0,
        currentTheme: 'modern',
        loading: true,
        error: null,
        submitting: false,
        submitted: false,

        async init() {
          await this.loadForm();
          this.initializeSearchableCheckboxes();
        },

        async loadForm() {
          try {
            const response = await fetch(`/api/v1/forms/${this.formId}`);
            const data = await response.json();

            if (data.ok && data.data) {
              this.formData = data.data;
              this.initializeFormValues();
            } else {
              this.error = 'Impossibile caricare il modulo';
            }
          } catch (err) {
            this.error = 'Errore di connessione al server';
            console.error(err);
          } finally {
            this.loading = false;
          }
        },

        initializeFormValues() {
          if (!this.formData.pages) return;

          this.formData.pages.forEach(page => {
            page.fields.forEach(field => {
              if (field.type === 'checkbox' || field.type === 'checkbox-multiple') {
                this.formValues[field.id] = [];
              } else {
                this.formValues[field.id] = '';
              }
            });
          });
        },

        initializeSearchableCheckboxes() {
          this.$nextTick(() => {
            const searchInputs = document.querySelectorAll('[id^="search-"]');
            searchInputs.forEach(input => {
              input.addEventListener('input', (e) => {
                const searchText = e.target.value.toLowerCase();
                const container = e.target.closest('div').nextElementSibling;
                const items = container.querySelectorAll('[data-search-text]');

                items.forEach(item => {
                  const text = item.getAttribute('data-search-text');
                  if (text.includes(searchText)) {
                    item.style.display = 'flex';
                  } else {
                    item.style.display = 'none';
                  }
                });
              });
            });
          });
        },

        updateCheckboxValue(fieldId, value, checked) {
          if (!Array.isArray(this.formValues[fieldId])) {
            this.formValues[fieldId] = [];
          }

          if (checked) {
            if (!this.formValues[fieldId].includes(value)) {
              this.formValues[fieldId].push(value);
            }
          } else {
            this.formValues[fieldId] = this.formValues[fieldId].filter(v => v !== value);
          }
        },

        validateCurrentPage() {
          if (!this.formData.pages || !this.formData.pages[this.currentPage]) return true;

          const currentPageData = this.formData.pages[this.currentPage];

          // If requireAllBeforeNext is true, validate all fields
          if (currentPageData.requireAllBeforeNext) {
            return this.validateAllFieldsOnPage();
          }

          return true;
        },

        nextPage() {
          // Validate all fields on current page before proceeding
          if (!this.validateAllFieldsOnPage()) {
            // Scroll to first error
            this.$nextTick(() => {
              const firstError = document.querySelector('.field-error');
              if (firstError) {
                firstError.scrollIntoView({ behavior: 'smooth', block: 'center' });
                firstError.focus();
              }
            });
            return;
          }

          if (this.currentPage < this.formData.pages.length - 1) {
            this.currentPage++;
            this.fieldErrors = {}; // Clear errors when changing page
            window.scrollTo({ top: 0, behavior: 'smooth' });
            this.initializeSearchableCheckboxes();
          }
        },

        previousPage() {
          if (this.currentPage > 0) {
            this.currentPage--;
            window.scrollTo({ top: 0, behavior: 'smooth' });
            this.initializeSearchableCheckboxes();
          }
        },

        async submitForm() {
          if (!this.validateCurrentPage()) return;

          this.submitting = true;

          try {
            <% if (recaptchaEnabled) { %>
            // Get reCAPTCHA token
            const recaptchaToken = await grecaptcha.execute('<%= recaptchaSiteKey %>', {
              action: this.formData.recaptcha?.action || 'submit'
            });
            <% } %>

            // Submit to API endpoint
            const payload = {
              formValues: this.formValues
              <% if (recaptchaEnabled) { %>,
              recaptchaToken: recaptchaToken
              <% } %>
            };

            const response = await fetch(`/api/v1/forms/${this.formId}/submit`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(payload)
            });

            const result = await response.json();

            if (response.ok && result.success) {
              this.submitted = true;
              window.scrollTo({ top: 0, behavior: 'smooth' });
              console.log('Submission successful:', result.submissionId);
            } else {
              // Handle error responses
              let errorMessage = result.message || this.formData.messages?.error || 'Si è verificato un errore durante l\'invio';

              if (response.status === 429) {
                errorMessage = result.message || 'Troppi tentativi. Riprova più tardi.';
              } else if (response.status === 403) {
                errorMessage = result.message || 'Verifica di sicurezza fallita. Riprova.';
              }

              alert(errorMessage);
              console.error('Submission error:', result);
            }

          } catch (err) {
            alert(this.formData.messages?.error || 'Si è verificato un errore durante l\'invio');
            console.error('Submission exception:', err);
          } finally {
            this.submitting = false;
          }
        },

        changeTheme(theme) {
          const body = document.body;
          body.classList.remove('theme-modern', 'theme-healthcare');
          body.classList.add(`theme-${theme}`);
          this.currentTheme = theme;
        },

        getFieldColSpan(field) {
          // Fields that should take full width
          if (field.type === 'textarea') return 'md:col-span-2';
          if (field.type === 'checkbox' || field.type === 'checkbox-multiple') return 'md:col-span-2';
          if (field.type === 'radio' && field.options && field.options.length > 3) return 'md:col-span-2';

          // Select with searchable or long options takes full width
          if (field.type === 'select' && (field.searchable || (field.options && field.options.length > 8))) {
            return 'md:col-span-2';
          }

          // Check if label or description is long
          if (field.label && field.label.length > 30) return 'md:col-span-2';
          if (field.description && field.description.length > 50) return 'md:col-span-2';

          // Default: single column (will be 2 columns on md+ screens)
          return 'md:col-span-1';
        },

        validateField(field) {
          const value = this.formValues[field.id];

          // Check required
          if (field.required) {
            if (Array.isArray(value)) {
              if (value.length === 0) {
                this.fieldErrors[field.id] = 'Campo obbligatorio';
                return false;
              }
            } else if (!value || value.trim() === '') {
              this.fieldErrors[field.id] = 'Campo obbligatorio';
              return false;
            }
          }

          // Check validation rules
          if (value && field.validation) {
            const validation = field.validation;

            // Length validations
            if (validation.minLength && value.length < validation.minLength) {
              this.fieldErrors[field.id] = `Minimo ${validation.minLength} caratteri`;
              return false;
            }
            if (validation.maxLength && value.length > validation.maxLength) {
              this.fieldErrors[field.id] = `Massimo ${validation.maxLength} caratteri`;
              return false;
            }

            // Number validations
            if (validation.type === 'number') {
              const num = parseFloat(value);
              if (isNaN(num)) {
                this.fieldErrors[field.id] = 'Deve essere un numero';
                return false;
              }
              if (validation.min !== undefined && num < validation.min) {
                this.fieldErrors[field.id] = `Minimo ${validation.min}`;
                return false;
              }
              if (validation.max !== undefined && num > validation.max) {
                this.fieldErrors[field.id] = `Massimo ${validation.max}`;
                return false;
              }
            }

            // Email validation
            if (validation.type === 'email') {
              const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
              if (!emailRegex.test(value)) {
                this.fieldErrors[field.id] = 'Email non valida';
                return false;
              }
            }

            // Phone validation
            if (validation.type === 'phone') {
              const phoneRegex = /^[\+]?[(]?[0-9]{1,4}[)]?[-\s\.]?[(]?[0-9]{1,4}[)]?[-\s\.]?[0-9]{1,9}$/;
              if (!phoneRegex.test(value.replace(/\s/g, ''))) {
                this.fieldErrors[field.id] = 'Telefono non valido';
                return false;
              }
            }

            // URL validation
            if (validation.type === 'url') {
              try {
                new URL(value);
              } catch (e) {
                this.fieldErrors[field.id] = 'URL non valido';
                return false;
              }
            }
          }

          // Clear error if validation passes
          delete this.fieldErrors[field.id];
          return true;
        },

        clearFieldError(fieldId) {
          if (this.fieldErrors[fieldId]) {
            delete this.fieldErrors[fieldId];
          }
        },

        validateAllFieldsOnPage() {
          if (!this.formData.pages || !this.formData.pages[this.currentPage]) return true;

          const currentPageData = this.formData.pages[this.currentPage];
          let isValid = true;

          currentPageData.fields.forEach(field => {
            if (!this.validateField(field)) {
              isValid = false;
            }
          });

          return isValid;
        }
      }
    }
  </script>

</body>
</html>
